LIST OF ALUFN OPCODES:

const ADD= b000000
const SUB= b000001
const AND= b011000
const OR= b011110
const XOR= b010110
const A= b011010
const SHL= b100000
const SHR= b100001
const SRA= b100011
const CMPEQ= b110011
const CMPLT= b110101
const CMPLE= b110111
const MUL= b000010
const DIV= b000011 
const FACTORIAL = b000110
const MODULO = b000111 

Test Cases:
(add edgecases and invalid alufn)

a) Addtester

1. ADD_overflow
0111111111111111 + 
0000000000000001 = 
1000000000000000
32767+1=32768 （Z=0, V=1, N=1) [pos+pos; overflow]

2. ADD_no_overflow 
0000000000000010 +
0000000000000101 =
0000000000000111 
(Z=0, V=0, N=0)


b) Subtester

1. SUBTRACT_overflow
1000000000000000 +1000000000000001
=1000000000000000
-0111111111111111
= //C31=1
 0000000000000001 (Z=0, V=1, N=0) [neg-pos, overflow]

2. SUBTRACT_no_overflow (when neg+ positive) 
0000000000000010 -0000000000000101
=0000000000000010 +
 1111111111111011
=1111111111111101 
 (Z=0, V=0, N=1) 
 
3. SUBTRACT_output_zero
0000000000000010-0000000000000010
= 0000000000000000
(Z=1, V=0, N=0)


c) Comparetester
//alu[15:1]=15b0 and alu[0]=boolean

1. Compare (=) subtraction ouput=0 => Z=1 
FALSE: 1000000000000000 vs 1000000000000001
TRUE:  1000000000000000 vs 1000000000000000 = also shows if Z is working

2.Compare (<) subtraction ouput; n xor v(n=0 means positive difference, thus not smaller unless there's overflow; vice versa)
TRUE: 1111111111111101- 1111111111111111 =0000000000000010 (eg. overflow when A is more negative than B) 
TRUE: 0000000000000001 00000000000000100 (eg. no overflow when A and B are both postive and A<B) 
EQUALTRUE: 0000000000000100 0000000000000100 should give false

3.Compare(<=) z or (n xor v) 
EQUALTRUE: 0000000000000100 0000000000000100 should give true 
FALSE: 0000000000000100 0000000000000001 


d) Shifttester: 

1. Shift right 
1000111100001111 
-> 0000000010001111 (shift 8)
-> 0100011110000111 (shift 1)

2. Shift left 
1010101010111111 
-> 1000000000000000 (shift 15)

3. Signed shift right 
0000111100001111->  0000000011110000 (shift 4)
1111001100110000->  1111111111111100 (shift 10) //replace with signed first bit


e) Booltester
Using the 2 values: 
0000111111111111
0000000000001111 //bitwise operation and can test for 0,0 0,1 1,0 1,1 bit combinations

1. AND: b0000000000001111
2. OR:  b0000111111111111 
3. A:   b1111000000001111 
4. XOR: b0000111111110000 


f) Multtester

1. MULTZERO
1111111111111111 x 0000000000000000 = 0000000000000000 
2. NEG * NEG 
1011110000111011 × 1111001100111000
= (01011001011010101)0010110111101000
3. MULTONE
1011110000111011 x 0000000000000001 = 1011110000111011  MULTONE
4. POS * POS
0111100001110110 × 0000111000000001 POS 
= (011010010110)1110110001110110


g) Factorialtester
1. 0!=1
2. 1!=1
3. 5!=120 =b0000000001111000

h) Modulotester
1. b0111111111111111 % b0000000000000001= 16b0 (modulo by 1)
2. b0000000000000001 % b0000000000000001= 16b0 (modulo by itself)
3. b0000000000000101 % b0000000000000010= b0000000000000001 (modulo by 2)
4. b0000000000001000 % b0000000000000101= b0000000000000011 (modulo by 5)

i) Divtester (floor division)
1. 8/2=4 R0
2. 9/3=3 R0
3. 13/3=4 R1
4. 2/8=0 R2

